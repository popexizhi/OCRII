# OCRII
验证码识别
原因---------------------------------------------------------------------------------------------------------
之前识别验证码用Tesseract-OCR ，但是当前工作环境使用的验证码变形比较厉害识别率太低了，就抽点儿时间自己写了一个，当前验证了一下对于4个 字符的验证码，识别率在20%～60%，感觉自己可以接受了，每次登录操作刷新5次一定可以登录[这个概率是可以接受的]，暂时不打算更新算法了。
代码地址如下：
https://github.com/popexizhi/OCRII
内容-------------------------------------------------------------------------------------------------------------
参考这个
http://vipscu.blog.163.com/blog/static/18180837220134234528457/
{unu} 二值化 Binarization.py 
[popexizhi:我的样本空间中有RGB{90,136,0}外的非噪声点，但没有处理，这也是为什么我的字库char-code 那么多冗余字符定义的原因，但最后实验中还是有11.23%左右因这个无法正确识别，下一步有时间这个位置的噪声隔离点打算使用直方图方式处理一下(http://www.bubuko.com/infodetail-318130.html)]
{du}  图像分割 diff_img.py :: split_img()
[popexzhi:修改了字库和切割的大小为16×25gif 点阵，这里的切割起点为(7,1)原文中为（16，2）这个应该和样本空间本身的起点位置有关吧！不过这是这个切割导致2，3，4位置的字符信息丢失很多，改进的话这里考虑不做切割直接在原图抠图定位会好一点]
{tri} 值对比diff_img.py :: recognize_x
[popexizh:这里沿用了点阵对比diff_rob::doing(),但样本中字库的二维移动导致这里的识别效果不好，补充了算法recognize_mave() 使用x，y轴的最高波动率识别，这个算法没有做波动率的最优估算，只是简单的峰值定位所以还是有不少的问题的，但鉴于现在识别率可以接受，就没有进一步优化]
next-------------------------------------------------------------------------------------------------------------
ok了，基本思路如上，下一步总结一下：
1.二值化噪声点优化
使用直方图方式处理一下(http://www.bubuko.com/infodetail-318130.html)[OKRS:使用样本中绿色字符保留/lower]
2.图像分割
在原图抠图定位[OKRS:起点定位，无切割引起的信息丢失/lower]
3.值对比
算法优化
[OKRS:
1.波动率最优评估左右平移90%正确/mid
2.波动率最优评估上下平移『包含信息丢失部分』70%正确/lower
3.写验证码生产的code/mid ---这个是因为从源头看看如何做的
4.char自识别class，使用每个字符自身最大信息识别--这个算法还在thinking中
5.使用openCV时考虑与Image结合识别
]
题外话-------------------------------------------------------------------------------------------------------------
PS:说说12306那个验证码吧，应该是字库足够就可以解决问题，但是对于人眼直接识别来说也太纠结了，要么不认识字要么不认识图，感觉这个改进应该是个UI上的倒退:)

原文地址：https://popexizhi.blogspot.com/b/post-preview?token=IUpomUwBAAA.fsIbaXfck4ZVbekFqtRTkw.Te1PcXZFyXexlR8p23ROoQ&postId=1652260327018406907&type=POST#!/2015/04/blog-post.html
